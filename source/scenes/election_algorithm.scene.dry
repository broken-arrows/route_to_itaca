title: Election
on-arrival: {!
// TODO: this is only for the national constituent assembly election. Petrograd elections will be different.
// calculate normalized class voting amounts (0 to 100)

for (var c of Q.classes) {
    var class_votes = 0;
    for (var party of Q.parties) {
        if (party == "none") {
            continue;
        }
        if (!Q[c+'_'+party] || Q[c+'_'+party] < 0) {
            Q[c+'_'+party] = 0;
        }
        class_votes += Q[c+'_'+party];
    }
    for (var party of Q.parties) {
        Q[c + '_' + party + '_normalized'] = 100*Q[c+'_'+party]/class_votes;
        Q[c + '_' + party + '_display'] = Math.round(100*Q[c+'_'+party]/class_votes);
    }
}

// 1. calculate support for each of the parties
var total_support = 0;
for (var party of Q.parties) {
    if (party == "none" || party == "anarchist") {
        continue;
    }
    var party_support = 0;
    for (var c of Q.classes) {
        party_support += Q[c]*Q[c+'_'+party+'_normalized'];
    }
    for (var c of Q.minorities) {
        if (Q[c + '_' + party]) {
            party_support += Q[c]*Q[c + '_' + party];
        }
    }
    Q[party + '_support'] = party_support;
    total_support += party_support;
}
// Calculate support for minority parties
for (var party of Q.minority_parties) {
    var m_party_support = 0;
    for (var c of Q.minorities) {
        if (Q[c + '_' + party]) {
            m_party_support += Q[c]*Q[c + '_' + party];
        }
    }
    Q[party + '_support'] = m_party_support;
    total_support += m_party_support;
}
// 2. normalize support (fraction)
// 3. Round to integers
// TODO: round to 1 decimal instead of rounding to integers
// to do that, we multiply party_normalized*1000 and divide the rounded number by 10.
for (var party of Q.parties) {
    if (party == "none" || party == "anarchist") {
        continue;
    }
    Q[party+'_assembly_normalized'] = Q[party + '_support']/total_support;
    Q[party+'_assembly_votes_dec'] = Math.round(Q[party+'_assembly_normalized']*1000)/10;
    Q[party+'_assembly_votes'] = Math.round(Q[party+'_assembly_normalized']*100);
    //Q[party+'_votes'] = Q[party+'_votes_dec'];
    // display
    Q[party + '_assembly_votes_disp'] = Q[party+'_assembly_votes_dec'].toFixed(1);
}
for (var party of Q.minority_parties) {
    Q[party+'_assembly_normalized'] = Q[party + '_support']/total_support;
    Q[party+'_assembly_votes_dec'] = Math.round(Q[party+'_assembly_normalized']*1000)/10;
    Q[party+'_assembly_votes'] = Math.round(Q[party+'_assembly_normalized']*100);
    //Q[party+'_votes'] = Q[party+'_votes_dec'];
    // display
    Q[party + '_assembly_votes_disp'] = Q[party+'_assembly_votes_dec'].toFixed(1);
}
!}
go-to: jumpScene

# note: this is a helpful utility to deal with elections and so on.


######################################## Parlament de Catalunya
@cat_parlament
title: Catalan Parlament Elections
on-arrival: {! 
// Store old results
for (var p of Q.parties) {
    // I.e. we show the party in the results table also if they HAD seats in the previous election
    // Some shenanigans may be needed for handling the name changing parties, WIP!

    if (Q[p+'_parlament_s'] > 0) {
        Q[p+'_parlament_showviz'] = 1;
    } else {
        Q[p+'_parlament_showviz'] = 0;
    }
    Q[p+'_parlament_pv_old'] = Q[p+'_parlament_pv'];
    Q[p+'_parlament_s_old'] = Q[p+'_parlament_s'];
    console.log(`Party ${p} old seats: ${Q[p+'_parlament_s']}`);
}

// 0. Initialize/reset vote and seat counts
for (var party of Q.parties) {
    for (var constituency of Q.parlament_constituencies) {
        Q[party + '_parlament_votes_' + constituency] = 0;
        Q[party + '_parlament_s_' + constituency] = 0;
    }
    Q[party+'_parlament_totalvotes'] = 0;
    Q[party+'_parlament_pv'] = 0;
    Q[party+'_parlament_s'] = 0;
}
Q.abstention_parlament_totalvotes = 0;
Q.abstention_parlament_pv = 0;

// 1. Calculate demographic weighted support for each party, per province
Q.parlament_totalpop = 0;
for (var constituency of Q.parlament_constituencies) {
    Q['parlament_' + constituency + '_totalpop'] = 0;
    Q['parlament_' + constituency + '_totalvotes'] = 0;
    Q['parlament_' + constituency + '_totalabstention'] = 0;
    for (var demographic of Q.parlament_demographics) {
        Q['parlament_' + constituency + '_totalpop'] += Q['parlament_' + constituency + '_pop_' + demographic];
        Q['parlament_' + constituency + '_totalabstention'] += Q['parlament_' + constituency + '_pop_' + demographic]*Q['parlament_' + constituency + '_' + demographic + '_abstention'];
        Q['parlament_' + constituency + '_totalvotes'] += Q['parlament_' + constituency + '_pop_' + demographic]*(1 - Q['parlament_' + constituency + '_' + demographic + '_abstention']);
        for (var party of Q.parties) {
            Q['parlament_' + constituency + '_' + party + '_votes'] += Q['parlament_' + constituency + '_pop_' + demographic] * Q[party + '_' + constituency + '_' + demographic +'_support'];
            console.log(`Votes for party ${party} in ${constituency} from demographic ${demographic}: ${Q['parlament_' + constituency + '_' + party + '_votes']}`);
        }
    }
}

// 2. Calculate popular vote percentages and abstention
for (var constituency of Q.parlament_constituencies) {
    for (var party of Q.parties) {
        Q[party+'_parlament_totalvotes'] += Q['parlament_' + constituency + '_' + party + '_votes'];
    }
    Q.abstention_parlament_totalvotes += Q['parlament_' + constituency + '_totalabstention'];
}
Q.abstention_parlament_pv = Math.round(Q.abstention_parlament_totalvotes / Q.parlament_totalpop * 1000) / 10;
for (var party of Q.parties) {
    Q[party+'_parlament_pv'] = Math.round(Q[party+'_parlament_totalvotes'] / (Q.parlament_totalpop - Q.abstention_parlament_totalvotes) * 1000) / 10;
    console.log(`Party ${party} total votes: ${Q[party+'_parlament_totalvotes']}, pv: ${Q[party+'_parlament_pv']}%`);
}


// 3. Apply 3% provincial thresholds
for (var constituency of Q.parlament_constituencies){
    for (var party of Q.parties) {
        if (Q['parlament_' + constituency + '_' + party + '_votes'] > 0.03 * Q['parlament_' + constituency + '_totalvotes']) {
            Q['parlament_' + constituency + '_' + party + '_is_in'] = 1;
        }
    }
}

// 4. Allocate seats via D'Hondt method
for (var constituency of Q.parlament_constituencies) {
    var seats_to_allocate = Q.parlament_seats[constituency];
    if (!seats_to_allocate || seats_to_allocate <= 0) {
        console.error(`No seats to allocate for constituency ${constituency}!!`);
        continue;
    }
    while (seats_to_allocate > 0) {
        var maxQuotient = 0;
        var winningParty = null;
        for (var party of Q.parties) {
            if (Q['parlament_' + constituency + '_' + party + '_is_in'] != 1) {
                continue;
            }
            var quotient = Q['parlament_' + constituency + '_' + party + '_votes'] / (Q[party + '_parlament_' + constituency + '_s'] + 1);
            if (quotient > maxQuotient) {
                maxQuotient = quotient;
                winningParty = party;
            }
        }
        if (winningParty) {
            Q[winningParty + '_parlament_' + constituency + '_s'] += 1;
            Q[winningParty + '_parlament_s'] += 1;
            seats_to_allocate -= 1;
        }
    }
    console.log(`Finished allocating seats for constituency ${constituency}`);
}


// 5. Post-process
// 5.1 Calculate percent of parlament control and deltas
for (var p of Q.parties) {
    if (Q[p+'_parlament_s'] > 0) {
        Q[p+'_parlament_spc'] = Math.round(Q[p+'_parlament_s'] / Q.parlament_size * 1000) / 10;
        Q[p+'_parlament_showviz'] = 1;
    } else {
        Q[p+'_parlament_spc'] = 0;
    }
    if (Q[p+'_parlament_s_old'] == 0 || !Q[p+'_parlament_s_old']) {
        Q[p+'_parlament_s_delta'] = '<div style="font-style: italic;">New!</div>';
        Q[p+'_parlament_pv_delta'] = '<div style="font-style: italic;">New!</div>';
    } else {
        Q[p+'_parlament_s_delta'] = Q[p+'_parlament_s'] - Q[p+'_parlament_s_old'];
        var sign1 = Q[p+'_parlament_s_delta'] > 0 ?
            '<img src="img/arrowup.png"> ' :
            Q[p+'_parlament_s_delta'] < 0 ? '<img src="img/arrowdown.png"> ' :
            '<img src="img/steady.png"> ';
        Q[p+'_parlament_s_delta'] = sign1 + Math.abs(Q[p+'_parlament_s_delta'])
        Q[p+'_parlament_pv_delta'] = Q[p+'_parlament_pv'] - Q[p+'_parlament_pv_old'];
        var sign2 = Q[p+'_parlament_pv_delta'] > 0 ?
            '<img src="img/arrowup.png"> ' :
            Q[p+'_parlament_pv_delta'] < 0 ? '<img src="img/arrowdown.png"> ' :
            '<img src="img/steady.png"> ';
        Q[p+'_parlament_pv_delta'] = sign2 + Math.abs(Q[p+'_parlament_pv_delta']).toFixed(1) + '%';
    }
}

// 5.2 Calculate block votes
Q.independence_parlament_pv = Q.ciu_parlament_pv + Q.erc_parlament_pv + Q.cup_parlament_pv + Q.junts_parlament_pv + Q.cdc_parlament_pv + Q.pdcat_parlament_pv + Q.jxsi_parlament_pv + Q.ac_parlament_pv + Q.si_parlament_pv ;
Q.independence_parlament_s = Q.ciu_parlament_s + Q.erc_parlament_s + Q.cup_parlament_s + Q.junts_parlament_s + Q.cdc_parlament_s + Q.pdcat_parlament_s + Q.jxsi_parlament_s + Q.ac_parlament_s + Q.si_parlament_s ;
Q.independence_parlament_spc = Math.round(Q.independence_parlament_s / Q.parlament_size * 1000) / 10;

Q.unionist_parlament_pv = Q.ppc_parlament_pv + Q.psc_parlament_pv + Q.cs_parlament_pv + Q.vox_parlament_pv + Q.ecp_parlament_pv;
Q.unionist_parlament_s = Q.ppc_parlament_s + Q.psc_parlament_s + Q.cs_parlament_s + Q.vox_parlament_s + Q.ecp_parlament_s;
Q.unionist_parlament_spc = Math.round(Q.unionist_parlament_s / Q.parlament_size * 1000) / 10;

Q.nonaligned_parlament_pv = Q.unio_parlament_pv + Q.icv_parlament_pv + Q.csqp_parlament_pv + Q.cecp_parlament_pv;
Q.nonaligned_parlament_s = Q.unio_parlament_s + Q.icv_parlament_s + Q.csqp_parlament_s + Q.cecp_parlament_s;
Q.nonaligned_parlament_spc = Math.round(Q.nonaligned_parlament_s / Q.parlament_size * 1000) / 10;


!}
go-to: jumpScene

######################################### Petrograd Soviet
@petrograd_soviet
title: Petrograd Soviet Elections
on-arrival: {!
var petrograd_classes = ["workers", "soldiers"];

for (var c of petrograd_classes) {
    var class_votes = 0;
    for (var party of Q.parties) {
        if (party == "none") {
            continue;
        }
        if (!Q[c+'_'+party] || Q[c+'_'+party] < 0) {
            Q[c+'_'+party] = 0;
        }
        class_votes += Q[c+'_'+party];
    }
    for (var party of Q.parties) {
        Q[c + '_' + party + '_normalized'] = 100*Q[c+'_'+party]/class_votes;
        Q[c + '_' + party + '_display'] = Math.round(100*Q[c+'_'+party]/class_votes);
    }
}

// 1. calculate support for each of the parties
var total_support = 0;
for (var party of Q.parties) {
    if (party == "none") {
        continue;
    }

    var party_support = 0;
    for (var c of petrograd_classes) {
        party_support += Q[c + '_petrograd']*Q[c+'_'+party+'_normalized'];
    }
    if (Q[party + '_soviet_bonus']) {
      party_support += Q[party + '_soviet_bonus'];
    }
    Q[party + '_support'] = party_support;
    total_support += party_support;
}
// 2. normalize support (fraction)
// 3. Round to integers
// TODO: round to 1 decimal instead of rounding to integers
// to do that, we multiply party_normalized*1000 and divide the rounded number by 10.
for (var party of Q.parties) {
    if (party == "none") {
        continue;
    }
    Q[party+'_soviet_normalized'] = Q[party + '_support']/total_support;
    Q[party+'_soviet_votes_dec'] = Math.round(Q[party+'_soviet_normalized']*1000)/10;
    Q[party+'_soviet_votes'] = Math.round(Q[party+'_soviet_normalized']*100);
    Q[party + '_soviet_votes_disp'] = Q[party+'_soviet_votes_dec'].toFixed(1);
}
!}
go-to: jumpScene


######################################### All-Russian Soviet
@all_russian_soviet
title: All-Russian Soviet Elections
on-arrival: {!
var soviet_classes = ["workers", "soldiers"];

for (var c of soviet_classes) {
    var class_votes = 0;
    for (var party of Q.parties) {
    if (party == "none") {
        continue;
    }

        if (!Q[c+'_'+party] || Q[c+'_'+party] < 0) {
            Q[c+'_'+party] = 0;
        }
        class_votes += Q[c+'_'+party];
    }
    for (var party of Q.parties) {
        Q[c + '_' + party + '_normalized'] = 100*Q[c+'_'+party]/class_votes;
        Q[c + '_' + party + '_display'] = Math.round(100*Q[c+'_'+party]/class_votes);
    }
}

// 1. calculate support for each of the parties
var total_support = 0;
for (var party of Q.parties) {
    if (party == "none") {
        continue;
    }

    var party_support = 0;
    for (var c of soviet_classes) {
        party_support += Q[c]*Q[c+'_'+party+'_normalized'];
    }
    Q[party + '_support'] = party_support;
    total_support += party_support;
}
// 2. normalize support (fraction)
// 3. Round to integers
// TODO: round to 1 decimal instead of rounding to integers
// to do that, we multiply party_normalized*1000 and divide the rounded number by 10.
for (var party of Q.parties) {
    if (party == "none") {
        continue;
    }

    Q[party+'_soviet_normalized'] = Q[party + '_support']/total_support;
    Q[party+'_soviet_votes_dec'] = Math.round(Q[party+'_soviet_normalized']*1000)/10;
    Q[party+'_soviet_votes'] = Math.round(Q[party+'_soviet_normalized']*100);
    Q[party + '_soviet_votes_disp'] = Q[party+'_soviet_votes_dec'].toFixed(1);
}
!}
go-to: jumpScene

######################################### Petrograd City Duma
@petrograd_duma
title: Petrograd Duma Elections
on-arrival: {!

for (var c of Q.classes) {
    var class_votes = 0;
    for (var party of Q.parties) {
    if (party == "none") {
        continue;
    }

        if (!Q[c+'_'+party] || Q[c+'_'+party] < 0) {
            Q[c+'_'+party] = 0;
        }
        class_votes += Q[c+'_'+party];
    }
    for (var party of Q.parties) {
        Q[c + '_' + party + '_normalized'] = 100*Q[c+'_'+party]/class_votes;
        Q[c + '_' + party + '_display'] = Math.round(100*Q[c+'_'+party]/class_votes);
    }
}

// 1. calculate support for each of the parties
var total_support = 0;
for (var party of Q.parties) {
    if (party == "none" || party == "anarchist") {
        continue;
    }

    var party_support = 0;
    for (var c of Q.classes) {
        party_support += Q[c + '_petrograd']*Q[c+'_'+party+'_normalized'];
    }
    Q[party + '_support'] = party_support;
    total_support += party_support;
}
// 2. normalize support (fraction)
// 3. Round to integers
// TODO: round to 1 decimal instead of rounding to integers
// to do that, we multiply party_normalized*1000 and divide the rounded number by 10.
for (var party of Q.parties) {
    if (party == "none" || party == "anarchist") {
        continue;
    }

    Q[party+'_city_duma_normalized'] = Q[party + '_support']/total_support;
    Q[party+'_city_duma_votes_dec'] = Math.round(Q[party+'_city_duma_normalized']*1000)/10;
    Q[party+'_city_duma_votes'] = Math.round(Q[party+'_city_duma_normalized']*100);
    Q[party + '_city_duma_votes_disp'] = Q[party+'_city_duma_votes_dec'].toFixed(1);
}
!}
go-to: jumpScene

